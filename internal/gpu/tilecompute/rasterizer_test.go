// Copyright 2026 The gogpu Authors
// SPDX-License-Identifier: MIT

package tilecompute

import (
	"image"
	"image/color"
	"image/png"
	"os"
	"path/filepath"
	"testing"

	"github.com/gogpu/gg/internal/raster"
)

// goldenTest defines a test case with parameters matching an upstream Vello scene.
type goldenTest struct {
	Name      string
	Width     int
	Height    int
	FillColor color.RGBA
	BgColor   color.RGBA // Background color
	FillRule  FillRule
	// BuildPath uses EdgeBuilder for curves (circles).
	BuildPath func(eb *raster.EdgeBuilder)
	// BuildLines generates LineSoup directly — includes ALL lines
	// (including horizontal), matching Vello's flattener behavior.
	BuildLines func() []LineSoup
	Threshold  float64
}

// gpuPipelineTests returns test cases for the Vello CPU pipeline.
// Golden images generated by running Vello with use_cpu: true (vello-gpu-golden utility).
// Velloport is a Go port of vello_shaders/src/cpu/ — the SAME algorithm (CPU-CPU comparison).
//
// Scenes match: sparse_strips/vello_sparse_tests/tests/basic.rs parameters,
// rendered through the CPU pipeline (fine.rs, not GPU shaders).
func gpuPipelineTests() []goldenTest {
	white := color.RGBA{R: 255, G: 255, B: 255, A: 255}
	lime := color.RGBA{R: 0, G: 255, B: 0, A: 255}
	maroon := color.RGBA{R: 128, G: 0, B: 0, A: 255}
	return []goldenTest{
		{
			Name:      "filled_circle",
			Width:     100,
			Height:    100,
			FillColor: lime,
			BgColor:   white,
			FillRule:  FillRuleNonZero,
			Threshold: 0.0, // CPU-CPU: pixel-perfect (Euler Spiral flatten + pipeline stages)
			BuildLines: func() []LineSoup {
				// Vello Euler Spiral flatten of Circle((50,50), 45)
				return FlattenFill(circleCubics(50, 50, 45))
			},
		},
		{
			Name:      "filled_triangle",
			Width:     100,
			Height:    100,
			FillColor: lime,
			BgColor:   white,
			FillRule:  FillRuleNonZero,
			Threshold: 0.0, // CPU-CPU: pixel-perfect (straight lines)
			BuildLines: func() []LineSoup {
				return polygonToLineSoup([][2]float32{
					{5, 5}, {95, 50}, {5, 95},
				})
			},
		},
		{
			Name:      "filling_nonzero_rule",
			Width:     100,
			Height:    100,
			FillColor: maroon,
			BgColor:   white,
			FillRule:  FillRuleNonZero,
			Threshold: 0.15, // CPU-CPU: 8px (0.08%) at float32 rounding boundaries (Rust vs Go)
			BuildLines: func() []LineSoup {
				return polygonToLineSoup([][2]float32{
					{50, 10}, {75, 90}, {10, 40}, {90, 40}, {25, 90},
				})
			},
		},
		{
			Name:      "filling_evenodd_rule",
			Width:     100,
			Height:    100,
			FillColor: maroon,
			BgColor:   white,
			FillRule:  FillRuleEvenOdd,
			Threshold: 0.15, // CPU-CPU: 10px (0.10%) at float32 rounding boundaries (Rust vs Go)
			BuildLines: func() []LineSoup {
				return polygonToLineSoup([][2]float32{
					{50, 10}, {75, 90}, {10, 40}, {90, 40}, {25, 90},
				})
			},
		},
	}
}

// gpuPipelineSmokeTests returns 20x20 smoke test scenes from vello_tests/snapshots/smoke/.
func gpuPipelineSmokeTests() []goldenTest {
	black := color.RGBA{R: 0, G: 0, B: 0, A: 255}
	blue := color.RGBA{R: 0, G: 0, B: 255, A: 255}
	return []goldenTest{
		{
			Name:      "smoke_filled_circle",
			Width:     20,
			Height:    20,
			FillColor: blue,
			BgColor:   black,
			FillRule:  FillRuleNonZero,
			Threshold: 0.0, // CPU-CPU: pixel-perfect (Euler Spiral flatten)
			BuildLines: func() []LineSoup {
				// Vello Euler Spiral flatten of Circle((10,10), 7)
				return FlattenFill(circleCubics(10, 10, 7))
			},
		},
		{
			Name:      "smoke_filled_square",
			Width:     20,
			Height:    20,
			FillColor: blue,
			BgColor:   black,
			FillRule:  FillRuleNonZero,
			Threshold: 0.0, // CPU-CPU: pixel-perfect (straight lines)
			BuildLines: func() []LineSoup {
				return polygonToLineSoup([][2]float32{
					{7, 7}, {13, 7}, {13, 13}, {7, 13},
				})
			},
		},
	}
}

// circleCubics returns a circle as 4 cubic Bezier curves (standard SVG/PDF representation).
// This matches kurbo's Circle.to_path() — 4 quadrant arcs approximated by cubics.
func circleCubics(cx, cy, r float32) []CubicBezier {
	// kappa = 4/3 * (sqrt(2) - 1) ≈ 0.5522847498
	const kappa float32 = 0.5522847498
	k := r * kappa
	return []CubicBezier{
		// Right → Bottom (quadrant 1: 0° → 90°)
		{P0: [2]float32{cx + r, cy}, P1: [2]float32{cx + r, cy + k}, P2: [2]float32{cx + k, cy + r}, P3: [2]float32{cx, cy + r}},
		// Bottom → Left (quadrant 2: 90° → 180°)
		{P0: [2]float32{cx, cy + r}, P1: [2]float32{cx - k, cy + r}, P2: [2]float32{cx - r, cy + k}, P3: [2]float32{cx - r, cy}},
		// Left → Top (quadrant 3: 180° → 270°)
		{P0: [2]float32{cx - r, cy}, P1: [2]float32{cx - r, cy - k}, P2: [2]float32{cx - k, cy - r}, P3: [2]float32{cx, cy - r}},
		// Top → Right (quadrant 4: 270° → 360°)
		{P0: [2]float32{cx, cy - r}, P1: [2]float32{cx + k, cy - r}, P2: [2]float32{cx + r, cy - k}, P3: [2]float32{cx + r, cy}},
	}
}

// polygonToLineSoup generates LineSoup from polygon vertices directly.
func polygonToLineSoup(vertices [][2]float32) []LineSoup {
	n := len(vertices)
	if n < 2 {
		return nil
	}
	lines := make([]LineSoup, 0, n)
	for i := 0; i < n; i++ {
		p0 := vertices[i]
		p1 := vertices[(i+1)%n]
		if p0[0] == p1[0] && p0[1] == p1[1] {
			continue
		}
		lines = append(lines, LineSoup{PathIx: 0, P0: p0, P1: p1})
	}
	return lines
}

func gpuPipelineGoldenPath(name string) string {
	return filepath.Join("..", "..", "..", "testdata", "golden", "vello-gpu-pipeline", name+".png")
}

func loadGoldenFile(t *testing.T, path string) *image.RGBA {
	t.Helper()
	f, err := os.Open(path)
	if err != nil {
		t.Skipf("golden file not found: %v", err)
		return nil
	}
	defer f.Close()
	img, err := png.Decode(f)
	if err != nil {
		t.Fatalf("failed to decode %s: %v", path, err)
	}
	rgba := image.NewRGBA(img.Bounds())
	for y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {
		for x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {
			rgba.Set(x, y, img.At(x, y))
		}
	}
	return rgba
}

// colorToArray converts color.RGBA to [4]uint8 for the rasterizer API.
func colorToArray(c color.RGBA) [4]uint8 {
	return [4]uint8{c.R, c.G, c.B, c.A}
}

func renderWithVelloPort(tc goldenTest) *image.RGBA {
	var lines []LineSoup

	if tc.BuildLines != nil {
		lines = tc.BuildLines()
	} else {
		eb := raster.NewEdgeBuilder(2) // 4x AA
		tc.BuildPath(eb)
		vlines := eb.VelloLines()
		lines = make([]LineSoup, len(vlines))
		for i, vl := range vlines {
			lines[i] = LineSoupFromVelloLine(vl.P0, vl.P1, vl.IsDown)
		}
	}

	r := NewRasterizer(tc.Width, tc.Height)
	return r.RasterizeScene(
		colorToArray(tc.BgColor),
		[]PathDef{{
			Lines:    lines,
			Color:    colorToArray(tc.FillColor),
			FillRule: tc.FillRule,
		}},
	)
}

func compareImages(img1, img2 *image.RGBA) (diffPercent float64, diffCount int) {
	bounds := img1.Bounds()
	totalPixels := bounds.Dx() * bounds.Dy()
	for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
		for x := bounds.Min.X; x < bounds.Max.X; x++ {
			c1 := img1.RGBAAt(x, y)
			c2 := img2.RGBAAt(x, y)
			if c1.R != c2.R || c1.G != c2.G || c1.B != c2.B || c1.A != c2.A {
				diffCount++
			}
		}
	}
	diffPercent = float64(diffCount) / float64(totalPixels) * 100
	return
}

func saveDiffImage(t *testing.T, prefix, name string, ours, reference *image.RGBA) {
	t.Helper()
	tmpDir := filepath.Join("..", "..", "..", "tmp")
	_ = os.MkdirAll(tmpDir, 0o755)

	diffImg := image.NewRGBA(ours.Bounds())
	for y := ours.Bounds().Min.Y; y < ours.Bounds().Max.Y; y++ {
		for x := ours.Bounds().Min.X; x < ours.Bounds().Max.X; x++ {
			v := ours.RGBAAt(x, y)
			g := reference.RGBAAt(x, y)
			if v.R != g.R || v.G != g.G || v.B != g.B {
				diffImg.Set(x, y, color.RGBA{R: 255, G: 0, B: 0, A: 255})
			} else {
				gray := uint8((uint32(v.R) + uint32(v.G) + uint32(v.B)) / 3)
				diffImg.Set(x, y, color.RGBA{R: gray, G: gray, B: gray, A: 255})
			}
		}
	}

	diffPath := filepath.Join(tmpDir, prefix+"_diff_"+name+".png")
	if f, err := os.Create(diffPath); err == nil {
		_ = png.Encode(f, diffImg)
		f.Close()
		t.Logf("Diff image saved: %s", diffPath)
	}

	oursPath := filepath.Join(tmpDir, prefix+"_ours_"+name+".png")
	if f, err := os.Create(oursPath); err == nil {
		_ = png.Encode(f, ours)
		f.Close()
		t.Logf("Our output saved: %s", oursPath)
	}
}

// TestVelloPortVsGPUPipeline compares tilecompute output against Vello CPU pipeline
// reference images. This is a SAME-ALGORITHM comparison: tilecompute ports
// vello_shaders/src/cpu/ and golden images are generated with use_cpu: true.
//
// Golden images generated by vello-gpu-golden Rust utility (Vello CPU path: fine.rs).
// Golden dir: testdata/golden/vello-gpu-pipeline/
func TestVelloPortVsGPUPipeline(t *testing.T) {
	tests := gpuPipelineTests()
	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			reference := loadGoldenFile(t, gpuPipelineGoldenPath(tc.Name))
			if reference == nil {
				return
			}

			if reference.Bounds().Dx() != tc.Width || reference.Bounds().Dy() != tc.Height {
				t.Fatalf("golden image %dx%d does not match expected %dx%d",
					reference.Bounds().Dx(), reference.Bounds().Dy(), tc.Width, tc.Height)
			}

			ours := renderWithVelloPort(tc)
			diffPercent, diffCount := compareImages(ours, reference)

			t.Logf("Scene: %s, Size: %dx%d, Diff: %d pixels (%.2f%%), Threshold: %.1f%%",
				tc.Name, tc.Width, tc.Height, diffCount, diffPercent, tc.Threshold)

			saveDiffImage(t, "tilecompute_gpu", tc.Name, ours, reference)

			if diffPercent > tc.Threshold {
				t.Errorf("FAIL: %.2f%% pixel difference exceeds threshold %.2f%%", diffPercent, tc.Threshold)
			}
		})
	}
}

// TestVelloPortVsGPUPipelineSmoke compares against 20x20 CPU pipeline smoke tests.
// These are smaller scenes that amplify any differences.
func TestVelloPortVsGPUPipelineSmoke(t *testing.T) {
	tests := gpuPipelineSmokeTests()
	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			reference := loadGoldenFile(t, gpuPipelineGoldenPath(tc.Name))
			if reference == nil {
				return
			}

			if reference.Bounds().Dx() != tc.Width || reference.Bounds().Dy() != tc.Height {
				t.Fatalf("golden image %dx%d does not match expected %dx%d",
					reference.Bounds().Dx(), reference.Bounds().Dy(), tc.Width, tc.Height)
			}

			ours := renderWithVelloPort(tc)
			diffPercent, diffCount := compareImages(ours, reference)

			t.Logf("Scene: %s, Size: %dx%d, Diff: %d pixels (%.2f%%), Threshold: %.1f%%",
				tc.Name, tc.Width, tc.Height, diffCount, diffPercent, tc.Threshold)

			saveDiffImage(t, "tilecompute_smoke", tc.Name, ours, reference)

			if diffPercent > tc.Threshold {
				t.Errorf("FAIL: %.2f%% pixel difference exceeds threshold %.2f%%", diffPercent, tc.Threshold)
			}
		})
	}
}

// savePNG writes an image to the tmp directory for visual inspection.
func savePNG(t *testing.T, img *image.RGBA, name string) {
	t.Helper()
	tmpDir := filepath.Join("..", "..", "..", "tmp")
	_ = os.MkdirAll(tmpDir, 0o755)
	path := filepath.Join(tmpDir, name+".png")
	f, err := os.Create(path)
	if err != nil {
		t.Logf("failed to save PNG %s: %v", path, err)
		return
	}
	defer f.Close()
	if err := png.Encode(f, img); err != nil {
		t.Logf("failed to encode PNG %s: %v", path, err)
		return
	}
	t.Logf("Saved: %s", path)
}

// TestVelloPortMultiPath verifies multi-path compositing via RasterizeScene.
// Two non-overlapping circles (red and blue) on a white background.
func TestVelloPortMultiPath(t *testing.T) {
	r := NewRasterizer(100, 100)
	white := [4]uint8{255, 255, 255, 255}

	// Red circle at (30, 50), radius 20
	redCircle := PathDef{
		Lines:    FlattenFill(circleCubics(30, 50, 20)),
		Color:    [4]uint8{255, 0, 0, 255},
		FillRule: FillRuleNonZero,
	}

	// Blue circle at (70, 50), radius 20
	blueCircle := PathDef{
		Lines:    FlattenFill(circleCubics(70, 50, 20)),
		Color:    [4]uint8{0, 0, 255, 255},
		FillRule: FillRuleNonZero,
	}

	img := r.RasterizeScene(white, []PathDef{redCircle, blueCircle})

	// Check: center of red circle should be solid red
	c := img.RGBAAt(30, 50)
	if c.R < 250 || c.G > 5 || c.B > 5 {
		t.Errorf("center of red circle: got (%d,%d,%d,%d), want ~(255,0,0,255)", c.R, c.G, c.B, c.A)
	}

	// Check: center of blue circle should be solid blue
	c = img.RGBAAt(70, 50)
	if c.R > 5 || c.G > 5 || c.B < 250 {
		t.Errorf("center of blue circle: got (%d,%d,%d,%d), want ~(0,0,255,255)", c.R, c.G, c.B, c.A)
	}

	// Check: background corner should be white
	c = img.RGBAAt(0, 0)
	if c.R != 255 || c.G != 255 || c.B != 255 {
		t.Errorf("background: got (%d,%d,%d,%d), want (255,255,255,255)", c.R, c.G, c.B, c.A)
	}

	// Save for visual inspection
	savePNG(t, img, "multipath_two_circles")
}

// TestVelloPortMultiPathOverlapping verifies compositing of overlapping shapes.
// A blue square partially covered by a semi-transparent green circle.
func TestVelloPortMultiPathOverlapping(t *testing.T) {
	r := NewRasterizer(100, 100)
	white := [4]uint8{255, 255, 255, 255}

	// Blue square (50x50 centered)
	blueSquare := PathDef{
		Lines: polygonToLineSoup([][2]float32{
			{25, 25}, {75, 25}, {75, 75}, {25, 75},
		}),
		Color:    [4]uint8{0, 0, 255, 255},
		FillRule: FillRuleNonZero,
	}

	// Semi-transparent red circle overlapping
	redCircle := PathDef{
		Lines:    FlattenFill(circleCubics(50, 50, 30)),
		Color:    [4]uint8{255, 0, 0, 128}, // 50% opacity
		FillRule: FillRuleNonZero,
	}

	img := r.RasterizeScene(white, []PathDef{blueSquare, redCircle})

	// Check: center pixel should be a blend of red over blue
	// Blue square fully covers center: (0,0,255,255)
	// Then semi-transparent red (alpha=128/255 ~= 0.502) composited over it
	// At the center, coverage alpha from rasterizer is ~1.0 for a large circle
	// srcA = 1.0 * 128/255 = 0.502
	// srcR = 255/255 * 0.502 = 0.502
	// outR = 0.502 + 0*(1-0.502) = 0.502 -> 128
	// outB = 0 + 255/255*(1-0.502) = 0.498 -> 127
	c := img.RGBAAt(50, 50)
	if c.R < 120 || c.R > 135 {
		t.Errorf("overlap center R: got %d, want ~128", c.R)
	}
	if c.B < 120 || c.B > 135 {
		t.Errorf("overlap center B: got %d, want ~127", c.B)
	}

	// Check: outside both shapes should be white
	c = img.RGBAAt(0, 0)
	if c.R != 255 || c.G != 255 || c.B != 255 {
		t.Errorf("background: got (%d,%d,%d,%d), want (255,255,255,255)", c.R, c.G, c.B, c.A)
	}

	savePNG(t, img, "multipath_overlapping")
}
