// Copyright 2026 The gogpu Authors
// SPDX-License-Identifier: BSD-3-Clause

package gpu

import (
	"github.com/gogpu/gg/internal/raster"
	"image"
	"image/color"
	"image/png"
	"os"
	"path/filepath"
	"testing"

	"github.com/gogpu/gg/scene"
)

// Golden file generation and comparison for Vello tile rasterizer.
//
// Golden files are reference images generated by AnalyticFiller (the trusted
// reference implementation). Tests compare Vello output against these files.
//
// To regenerate golden files:
//
//	GENERATE_GOLDEN=1 go test -v -run TestGenerateGoldenFiles ./internal/gpu/...
//
// Golden files location: testdata/golden/vello/

// GoldenTestCase defines a shape for golden file testing.
type GoldenTestCase struct {
	Name      string
	Width     int
	Height    int
	BuildPath func(eb *raster.EdgeBuilder)
	Threshold float64 // Acceptable difference percentage
}

// StandardGoldenTests returns the standard set of golden test cases.
func StandardGoldenTests() []GoldenTestCase {
	return []GoldenTestCase{
		{
			Name:      "square_6x6",
			Width:     20,
			Height:    20,
			Threshold: 0.0, // Squares must be exact
			BuildPath: func(eb *raster.EdgeBuilder) {
				// Square at center (10,10), size 6x6 = corners (7,7) to (13,13)
				path := scene.NewPath()
				path.MoveTo(7, 7)
				path.LineTo(13, 7)
				path.LineTo(13, 13)
				path.LineTo(7, 13)
				path.Close()
				eb.SetFlattenCurves(true)
				BuildEdgesFromScenePath(eb, path, scene.IdentityAffine())
			},
		},
		{
			Name:      "circle_r7",
			Width:     20,
			Height:    20,
			Threshold: 15.0, // VelloLine float coords produce different AA at curve edges
			BuildPath: func(eb *raster.EdgeBuilder) {
				// Circle at (10, 10), radius 7
				cx, cy := float32(10), float32(10)
				radius := float32(7)
				const k = 0.5522847498 // Cubic bezier circle approximation constant
				path := scene.NewPath()
				path.MoveTo(cx+radius, cy)
				path.CubicTo(cx+radius, cy-radius*k, cx+radius*k, cy-radius, cx, cy-radius)
				path.CubicTo(cx-radius*k, cy-radius, cx-radius, cy-radius*k, cx-radius, cy)
				path.CubicTo(cx-radius, cy+radius*k, cx-radius*k, cy+radius, cx, cy+radius)
				path.CubicTo(cx+radius*k, cy+radius, cx+radius, cy+radius*k, cx+radius, cy)
				path.Close()
				eb.SetFlattenCurves(true)
				BuildEdgesFromScenePath(eb, path, scene.IdentityAffine())
			},
		},
		{
			Name:      "circle_r60",
			Width:     200,
			Height:    200,
			Threshold: 2.0, // VelloLine float coords produce different AA at curve edges
			BuildPath: func(eb *raster.EdgeBuilder) {
				// Circle at (100, 100), radius 60
				cx, cy := float32(100), float32(100)
				radius := float32(60)
				const k = 0.5522847498
				path := scene.NewPath()
				path.MoveTo(cx+radius, cy)
				path.CubicTo(cx+radius, cy-radius*k, cx+radius*k, cy-radius, cx, cy-radius)
				path.CubicTo(cx-radius*k, cy-radius, cx-radius, cy-radius*k, cx-radius, cy)
				path.CubicTo(cx-radius, cy+radius*k, cx-radius*k, cy+radius, cx, cy+radius)
				path.CubicTo(cx+radius*k, cy+radius, cx+radius, cy+radius*k, cx+radius, cy)
				path.Close()
				eb.SetFlattenCurves(true)
				BuildEdgesFromScenePath(eb, path, scene.IdentityAffine())
			},
		},
		{
			Name:      "circle_r80",
			Width:     200,
			Height:    200,
			Threshold: 2.0, // VelloLine float coords produce different AA at curve edges
			BuildPath: func(eb *raster.EdgeBuilder) {
				// Circle at (100, 100), radius 80 - matches TestVelloVisualCircle
				cx, cy := float32(100), float32(100)
				radius := float32(80)
				const k = 0.5522847498
				path := scene.NewPath()
				path.MoveTo(cx+radius, cy)
				path.CubicTo(cx+radius, cy-radius*k, cx+radius*k, cy-radius, cx, cy-radius)
				path.CubicTo(cx-radius*k, cy-radius, cx-radius, cy-radius*k, cx-radius, cy)
				path.CubicTo(cx-radius, cy+radius*k, cx-radius*k, cy+radius, cx, cy+radius)
				path.CubicTo(cx+radius*k, cy+radius, cx+radius, cy+radius*k, cx+radius, cy)
				path.Close()
				eb.SetFlattenCurves(true)
				BuildEdgesFromScenePath(eb, path, scene.IdentityAffine())
			},
		},
		{
			Name:      "diagonal_stripe",
			Width:     200,
			Height:    200,
			Threshold: 2.0, // VelloLine float coords avoid fixed-point X quantization
			BuildPath: func(eb *raster.EdgeBuilder) {
				// Diagonal stripe from (10,10) to (190,190), thickness 20
				thickness := float32(20)
				path := scene.NewPath()
				path.MoveTo(10, 10)
				path.LineTo(10+thickness, 10)
				path.LineTo(190, 190-thickness)
				path.LineTo(190, 190)
				path.LineTo(190-thickness, 190)
				path.LineTo(10, 10+thickness)
				path.Close()
				eb.SetFlattenCurves(true)
				BuildEdgesFromScenePath(eb, path, scene.IdentityAffine())
			},
		},
		{
			Name:      "rectangle_aligned",
			Width:     64,
			Height:    64,
			Threshold: 15.0, // TODO: Investigate tile-boundary differences
			BuildPath: func(eb *raster.EdgeBuilder) {
				// Rectangle aligned to tile boundaries (16x16 tiles)
				// From (16,16) to (48,48) = 2x2 tiles
				// NOTE: Vello and AnalyticFiller handle tile-aligned edges differently
				path := scene.NewPath()
				path.MoveTo(16, 16)
				path.LineTo(48, 16)
				path.LineTo(48, 48)
				path.LineTo(16, 48)
				path.Close()
				eb.SetFlattenCurves(true)
				BuildEdgesFromScenePath(eb, path, scene.IdentityAffine())
			},
		},
		{
			Name:      "rectangle_unaligned",
			Width:     64,
			Height:    64,
			Threshold: 5.0, // TODO: Investigate tile-crossing differences
			BuildPath: func(eb *raster.EdgeBuilder) {
				// Rectangle NOT aligned to tile boundaries
				// From (10,10) to (54,54) - crosses tile boundaries
				// NOTE: Different backdrop handling at tile crossings
				path := scene.NewPath()
				path.MoveTo(10, 10)
				path.LineTo(54, 10)
				path.LineTo(54, 54)
				path.LineTo(10, 54)
				path.Close()
				eb.SetFlattenCurves(true)
				BuildEdgesFromScenePath(eb, path, scene.IdentityAffine())
			},
		},
	}
}

// goldenDir returns the path to golden files directory.
func goldenDir() string {
	return filepath.Join("..", "..", "testdata", "golden", "vello")
}

// goldenPath returns the path for a specific golden file.
func goldenPath(name string) string {
	return filepath.Join(goldenDir(), name+".png")
}

// renderWithAnalyticFiller renders a shape using the reference implementation.
func renderWithAnalyticFiller(tc GoldenTestCase) *image.RGBA {
	img := image.NewRGBA(image.Rect(0, 0, tc.Width, tc.Height))

	// White background
	for y := 0; y < tc.Height; y++ {
		for x := 0; x < tc.Width; x++ {
			img.Set(x, y, color.RGBA{R: 255, G: 255, B: 255, A: 255})
		}
	}

	af := NewAnalyticFiller(tc.Width, tc.Height)
	eb := raster.NewEdgeBuilder(2) // 4x AA
	tc.BuildPath(eb)

	af.Fill(eb, raster.FillRuleNonZero, func(y int, runs *raster.AlphaRuns) {
		for x, alpha := range runs.Iter() {
			if alpha <= 0 {
				continue
			}
			// Blue color with alpha blending on white
			a := float32(alpha) / 255.0
			r := uint8(255 * (1 - a))
			g := uint8(255 * (1 - a))
			b := uint8(255*a + 255*(1-a))
			img.Set(x, y, color.RGBA{R: r, G: g, B: b, A: 255})
		}
	})

	return img
}

// renderWithVello renders a shape using the Vello tile rasterizer.
func renderWithVello(tc GoldenTestCase) *image.RGBA {
	img := image.NewRGBA(image.Rect(0, 0, tc.Width, tc.Height))

	// White background
	for y := 0; y < tc.Height; y++ {
		for x := 0; x < tc.Width; x++ {
			img.Set(x, y, color.RGBA{R: 255, G: 255, B: 255, A: 255})
		}
	}

	tr := NewTileRasterizer(tc.Width, tc.Height)
	eb := raster.NewEdgeBuilder(2) // 4x AA
	tc.BuildPath(eb)

	tr.Fill(eb, raster.FillRuleNonZero, func(y int, runs *raster.AlphaRuns) {
		for x, alpha := range runs.Iter() {
			if alpha <= 0 {
				continue
			}
			// Blue color with alpha blending on white
			a := float32(alpha) / 255.0
			r := uint8(255 * (1 - a))
			g := uint8(255 * (1 - a))
			b := uint8(255*a + 255*(1-a))
			img.Set(x, y, color.RGBA{R: r, G: g, B: b, A: 255})
		}
	})

	return img
}

// compareImages returns the percentage of different pixels.
func compareImages(img1, img2 *image.RGBA) (diffPercent float64, diffCount int) {
	bounds := img1.Bounds()
	totalPixels := bounds.Dx() * bounds.Dy()

	for y := bounds.Min.Y; y < bounds.Max.Y; y++ {
		for x := bounds.Min.X; x < bounds.Max.X; x++ {
			c1 := img1.RGBAAt(x, y)
			c2 := img2.RGBAAt(x, y)
			if c1.R != c2.R || c1.G != c2.G || c1.B != c2.B || c1.A != c2.A {
				diffCount++
			}
		}
	}

	diffPercent = float64(diffCount) / float64(totalPixels) * 100
	return
}

// TestGenerateGoldenFiles generates golden files using AnalyticFiller.
// Run with: GENERATE_GOLDEN=1 go test -v -run TestGenerateGoldenFiles ./internal/gpu/...
func TestGenerateGoldenFiles(t *testing.T) {
	if os.Getenv("GENERATE_GOLDEN") != "1" {
		t.Skip("set GENERATE_GOLDEN=1 to regenerate golden files")
	}

	// Create golden directory
	dir := goldenDir()
	if err := os.MkdirAll(dir, 0o755); err != nil {
		t.Fatalf("failed to create golden dir: %v", err)
	}

	tests := StandardGoldenTests()
	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			img := renderWithAnalyticFiller(tc)

			path := goldenPath(tc.Name)
			f, err := os.Create(path)
			if err != nil {
				t.Fatalf("failed to create %s: %v", path, err)
			}
			defer f.Close()

			if err := png.Encode(f, img); err != nil {
				t.Fatalf("failed to encode %s: %v", path, err)
			}

			t.Logf("Generated: %s (%dx%d)", path, tc.Width, tc.Height)
		})
	}
}

// TestVelloAgainstGolden compares Vello output against golden files.
func TestVelloAgainstGolden(t *testing.T) {
	tests := StandardGoldenTests()

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			// Load golden file
			goldenFile, err := os.Open(goldenPath(tc.Name))
			if err != nil {
				t.Skipf("golden file not found: %v (run with -generate-golden to create)", err)
			}
			defer goldenFile.Close()

			golden, err := png.Decode(goldenFile)
			if err != nil {
				t.Fatalf("failed to decode golden: %v", err)
			}

			// Render with Vello
			velloImg := renderWithVello(tc)

			// Convert golden to RGBA for comparison
			goldenRGBA := image.NewRGBA(golden.Bounds())
			for y := golden.Bounds().Min.Y; y < golden.Bounds().Max.Y; y++ {
				for x := golden.Bounds().Min.X; x < golden.Bounds().Max.X; x++ {
					goldenRGBA.Set(x, y, golden.At(x, y))
				}
			}

			// Compare
			diffPercent, diffCount := compareImages(velloImg, goldenRGBA)

			t.Logf("Shape: %s, Size: %dx%d, Diff: %d pixels (%.2f%%), Threshold: %.2f%%",
				tc.Name, tc.Width, tc.Height, diffCount, diffPercent, tc.Threshold)

			if diffPercent > tc.Threshold {
				// Save diff image for debugging
				tmpDir := filepath.Join("..", "..", "tmp")
				_ = os.MkdirAll(tmpDir, 0o755)

				diffImg := image.NewRGBA(velloImg.Bounds())
				for y := velloImg.Bounds().Min.Y; y < velloImg.Bounds().Max.Y; y++ {
					for x := velloImg.Bounds().Min.X; x < velloImg.Bounds().Max.X; x++ {
						v := velloImg.RGBAAt(x, y)
						g := goldenRGBA.RGBAAt(x, y)
						if v.R != g.R || v.G != g.G || v.B != g.B {
							diffImg.Set(x, y, color.RGBA{R: 255, G: 0, B: 0, A: 255})
						} else {
							gray := uint8((uint32(v.R) + uint32(v.G) + uint32(v.B)) / 3)
							diffImg.Set(x, y, color.RGBA{R: gray, G: gray, B: gray, A: 255})
						}
					}
				}

				diffPath := filepath.Join(tmpDir, "golden_diff_"+tc.Name+".png")
				if f, err := os.Create(diffPath); err == nil {
					_ = png.Encode(f, diffImg)
					f.Close()
					t.Logf("Diff image saved: %s", diffPath)
				}

				t.Errorf("FAIL: %.2f%% difference exceeds threshold %.2f%%", diffPercent, tc.Threshold)
			}
		})
	}
}
