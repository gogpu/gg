# Алгоритм Vello Tile-Based Rasterization

## Обзор

Vello — это современный алгоритм растеризации векторной графики, разработанный Google для высокопроизводительного рендеринга на GPU. Данный документ описывает нашу Go-реализацию CPU-версии алгоритма и решение ключевой проблемы с propagation backdrop.

## Основные концепции

### Тайловая архитектура

Изображение разбивается на квадратные тайлы размером 16×16 пикселей. Каждый тайл обрабатывается независимо, что обеспечивает параллелизм на GPU и локальность данных на CPU.

```
┌────────┬────────┬────────┬────────┐
│ Tile   │ Tile   │ Tile   │ Tile   │
│ (0,0)  │ (1,0)  │ (2,0)  │ (3,0)  │
├────────┼────────┼────────┼────────┤
│ Tile   │ Tile   │ Tile   │ Tile   │
│ (0,1)  │ (1,1)  │ (2,1)  │ (3,1)  │
└────────┴────────┴────────┴────────┘
```

### Winding Number (число обхода)

Для определения принадлежности пикселя к фигуре используется правило ненулевого числа обхода (non-zero winding rule). Луч, выпущенный из пикселя влево до бесконечности, подсчитывает пересечения с контуром:
- Пересечение снизу вверх: +1
- Пересечение сверху вниз: −1
- Если сумма ≠ 0, пиксель внутри фигуры

### Backdrop

**Backdrop** — это накопленное число обхода, передаваемое от левых тайлов к правым. Вместо того чтобы для каждого пикселя выпускать луч до края изображения, мы передаём уже подсчитанное значение между соседними тайлами.

```
Тайл A          Тайл B          Тайл C
┌──────────┐    ┌──────────┐    ┌──────────┐
│    ╲     │    │          │    │          │
│     ╲    │───►│ backdrop │───►│ backdrop │
│      ╲   │ +1 │   = 1    │ +0 │   = 1    │
└──────────┘    └──────────┘    └──────────┘
```

Сегмент в тайле A пересекает вертикальную границу → backdrop увеличивается на 1 → тайлы B и C знают, что находятся внутри фигуры.

### Сегменты и Y-Edge

Каждый тайл хранит список **сегментов** — отрезков контура, проходящих через тайл. Сегмент содержит:
- `Point0`, `Point1` — начальная и конечная точки (в координатах тайла, 0-16)
- `YEdge` — специальное значение для компенсации частичного заполнения

**Y-Edge механизм**: когда сегмент касается левого края тайла (x=0), значение `YEdge` указывает, с какой строки начинать заполнение. Это позволяет корректно обрабатывать случаи, когда фигура входит в тайл не с самого верха.

## Алгоритм растеризации

### Этап 1: Binning (распределение сегментов по тайлам)

Функция `binSegments` обходит все сегменты контура и распределяет их по тайлам:

1. **Flatten** — кривые Безье разбиваются на линейные сегменты
2. **DDA (Digital Differential Analyzer)** — для каждого сегмента определяются все тайлы, через которые он проходит
3. **Backdrop propagation** — при пересечении вертикальной границы тайла обновляется backdrop соседнего тайла

```
Сегмент (10,10) → (50,30):

     Y
     ↑
  30 ┤        ╱ конец
     │      ╱
     │    ╱
  10 ┤  ╱ начало
     │
     └──┬────┬────┬────► X
        16   32   48

Тайлы: (0,0), (1,0), (1,1), (2,1), (3,1)
```

### Этап 2: Fill (заполнение тайлов)

Функция `fillTileScanline` обрабатывает каждый тайл построчно:

1. Для каждой строки пикселей (y = 0..15):
   - Инициализировать `area` = backdrop × 256 (полное покрытие)
   - Для каждого сегмента, пересекающего строку:
     - Вычислить покрытие пикселя методом трапеций
     - Обновить `area` в зависимости от направления сегмента
   - Применить `area` к пикселям строки

2. **Антиалиасинг** достигается за счёт точного вычисления площади покрытия каждого пикселя сегментом (значения 0-255).

## Проблема: DDA пропускает первую строку

### Описание

При обработке сегмента алгоритм DDA вычисляет индексы строк тайлов:

```go
s0y := (y0 - tileY0*tileH) / tileH  // начало в тайловых координатах
imin := int(math.Ceil(float64(s0y))) // первая строка для обработки
```

Если сегмент начинается **внутри** тайла (например, y=10 в тайле 0-15), то:
- `s0y = 10/16 = 0.625`
- `imin = ceil(0.625) = 1`
- **Строка 0 пропускается!**

### Последствия

Для фигуры с вертикальным краем, начинающимся внутри тайла:

```
Диагональ начинается в (10, 10):

Tile(0,0)     Tile(1,0)     Tile(2,0)
┌──────────┐  ┌──────────┐  ┌──────────┐
│          │  │          │  │          │
│    │     │  │ ???????? │  │ ???????? │  ← строки 0-9 не заполнены!
│    │█████│  │ backdrop │  │ backdrop │
│    │█████│  │   = ???  │  │   = ???  │
└──────────┘  └──────────┘  └──────────┘
```

Тайлы справа от вертикального края не получают backdrop для строк выше начала сегмента.

## Решение: синтетический Y-Edge сегмент

### Идея

Для **идеально вертикальных** краёв (dx = 0), начинающихся внутри тайла, мы добавляем синтетический сегмент с установленным `YEdge`. Этот сегмент сообщает соседнему тайлу: "заполняй строки начиная с Y = startY".

### Условия применения

Fix применяется только когда **все** условия выполнены:

1. `i == 0` — это первая итерация DDA (начало сегмента)
2. `!topEdge` — сегмент начинается внутри тайла, не на границе
3. `tileX == bboxMinX` — это самая левая колонка пути
4. `dx == 0` — край **идеально вертикальный**

### Почему только dx == 0?

| Тип края | dx | Нужен fix? |
|----------|-----|-----------|
| Вертикальный край прямоугольника | 0 | ✅ Да |
| Сегмент круга (аппроксимация Безье) | −0.20 | ❌ Нет |
| Диагональный сегмент | 5.5 | ❌ Нет |

Круг аппроксимируется кривыми Безье, которые разбиваются на короткие сегменты с малым, но **ненулевым** dx. Применение fix к таким сегментам создаёт артефакты.

### Реализация

```go
// В binSegments, DDA loop (vello_tiles.go:441)

edgeDx := x1 - x0
isVertical := edgeDx == 0                              // ТОЛЬКО идеально вертикальные!
tileRightEdge := float32((tileX + 1) * VelloTileWidth) // Правый край текущего тайла
shapeExtendsRightOfTile := bounds.MaxX > tileRightEdge // Форма выходит за тайл

if i == 0 && !topEdge && tileX == bboxMinX && isVertical && shapeExtendsRightOfTile && tileX+1 < tr.tilesX {
    // Вычисляем Y начала сегмента в координатах тайла
    segStartY := (s0y - float32(tileY)) * VelloTileHeight
    if segStartY < 0 {
        segStartY = 0
    }

    // Добавляем синтетический сегмент в соседний тайл справа
    xBump := tileX + 1
    tileIdx := tileY*tr.tilesX + xBump

    tr.tiles[tileIdx].Segments = append(tr.tiles[tileIdx].Segments, PathSegment{
        Point0: [2]float32{0, segStartY},
        Point1: [2]float32{epsilon, segStartY},  // минимальное смещение
        YEdge:  segStartY,  // заполнять начиная с этой строки
    })
}
```

### Важное уточнение: проверка shapeExtendsRightOfTile

Первоначальная версия fix использовала `bboxMaxX > bboxMinX` для проверки того, что фигура
охватывает несколько тайлов. Однако это было некорректно, так как bbox вычисляется через
`ceil()` и может показывать "span" даже для фигур целиком внутри одного тайла.

**Пример проблемы:**
- Квадрат с координатами (7,7)-(13,13)
- bboxMinX = floor(7/16) = 0
- bboxMaxX = ceil(13/16) = ceil(0.8125) = 1
- bboxMaxX > bboxMinX → true (НЕКОРРЕКТНО!)

**Решение:**
Проверять `bounds.MaxX > tileRightEdge` — реальную координату правой границы формы
относительно правого края текущего тайла.

### Как это работает

До fix:
```
Tile(1,0): backdrop=0, segments=[]
→ Строки 10-15 не заполнены (нет информации о заполнении)
```

После fix:
```
Tile(1,0): backdrop=0, segments=[{Point0:(0,10), Point1:(ε,10), YEdge:10}]
→ YEdge=10 говорит: "заполняй строки Y ≥ 10"
→ Строки 10-15 корректно заполнены
```

## Результаты

| Тест | До исправления | После исправления |
|------|----------------|-------------------|
| Диагональ | 0.24% (96 пикселей) | **0.00%** |
| Круг | 0.02% (7 пикселей) | **0.02%** |
| Квадрат | 6.00% (24 пикселя) | **0.00%** |

Диагональная фигура и квадрат теперь рендерятся идентично эталонной реализации (AnalyticFiller).
Круг не затронут, так как не имеет идеально вертикальных краёв.

## Ключевые файлы

| Файл | Назначение |
|------|------------|
| `backend/native/vello_tiles.go` | Основная реализация алгоритма |
| `backend/native/analytic_filler.go` | Эталонная реализация для сравнения |
| `backend/native/vello_visual_test.go` | Визуальные тесты |

## Коммиты

```
e0f9137 fix(vello): backdrop propagation for vertical edges starting inside tiles
744b1af fix(vello): use AddWithCoverage in emitScanline for uniform alpha runs
497bda0 fix(vello): prevent synthetic segment for shapes within single tile
```

---

*Документ создан: 2026-02-01*
